#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>

#include <png.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>


typedef struct  //структура для для
{
    int key;
    int val;
}pair;

/*  цвет */

typedef struct {
    uint8_t red;
    uint8_t green;
    uint8_t blue;
    uint8_t alpha;
} pixel_t;

/* картинка */

typedef struct {
    pixel_t* pixels;
    size_t width;
    size_t height;
} bitmap_t;

/* Given "bitmap", this returns the pixel of bitmap at the point
("x", "y"). */

static pixel_t* pixel_at(bitmap_t* bitmap, int x, int y)
{
    return bitmap->pixels + bitmap->width * y + x;
}

/* Write "bitmap" to a PNG file specified by "path"; returns 0 on
success, non-zero on error. */

static int save_png_to_file(bitmap_t* bitmap, const char* path)
{
    FILE* fp;
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL;
    size_t x, y;
    png_byte** row_pointers = NULL;
    int status = -1;
    int pixel_size = 50;
    int depth = 8;

    fp = fopen(path, "wb");
    if (!fp) {
        goto fopen_failed;
    }

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (png_ptr == NULL) {
        goto png_create_write_struct_failed;
    }

    info_ptr = png_create_info_struct(png_ptr);
    if (info_ptr == NULL) {
        goto png_create_info_struct_failed;
    }


    if (setjmp(png_jmpbuf(png_ptr))) {
        goto png_failure;
    }


    png_set_IHDR(png_ptr,
        info_ptr,
        bitmap->width,
        bitmap->height,
        depth,
        PNG_COLOR_TYPE_RGBA,
        PNG_INTERLACE_NONE,
        PNG_COMPRESSION_TYPE_DEFAULT,
        PNG_FILTER_TYPE_DEFAULT);


    row_pointers = png_malloc(png_ptr, bitmap->height * sizeof(png_byte*));
    for (y = 0; y < bitmap->height; ++y) {
        png_byte* row =
            png_malloc(png_ptr, sizeof(uint8_t) * bitmap->width * pixel_size);
        row_pointers[y] = row;
        for (x = 0; x < bitmap->width; ++x) {
            pixel_t* pixel = pixel_at(bitmap, x, y);
            *row++ = pixel->red;
            *row++ = pixel->green;
            *row++ = pixel->blue;
            *row++ = pixel->alpha;
        }
    }

    /* Write the image data to "fp". */

    png_init_io(png_ptr, fp);
    png_set_rows(png_ptr, info_ptr, row_pointers);
    png_write_png(png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, NULL);

    /* The routine has successfully written the file, so we set
    "status" to a value which indicates success. */

    status = 0;

    for (y = 0; y < bitmap->height; y++) {
        png_free(png_ptr, row_pointers[y]);
    }
    png_free(png_ptr, row_pointers);

png_failure:
png_create_info_struct_failed:
    png_destroy_write_struct(&png_ptr, &info_ptr);
png_create_write_struct_failed:
    fclose(fp);
fopen_failed:
    return status;
}

/* Given "value" and "max", the maximum value which we expect "value"
to take, this returns an integer between 0 and 255 proportional to
"value" divided by "max". */

static int pix(int value, int max)
{
    if (value < 0)
        return 0;
    return (int)(256.0 * ((double)(value) / (double)max));
}

//

void DrawAndSave(pair arr[], int n) // массив, колво, номер для сохранения
{
    bitmap_t fruit;
    static int num=0;
    static int num1=0;
    fruit.width = 20*n;
    fruit.height = 20*n;
    fruit.pixels = calloc(sizeof(pixel_t), fruit.width * fruit.height);
    int y;
    int x;
    int xx1 = 0;
    for (int i = 0; i < n; i++)
    {
        for (y =100 - arr[i].val*4; y < 100; y++)
        {
            for (x = 0; x < 8; x++)
            {
                x += xx1;
                pixel_t* pixel = pixel_at(&fruit, x, y);
                pixel->green = 100;
                pixel->blue = 0;
                pixel->red = 0;
                pixel->alpha = pix(99, 100);
                x = x - xx1;
            }
        }
        xx1 += 17;
    }
    const char* name[5];
    const char* surname[5];
    char png[] = { ".png" };
    name[0] = '0' + num;
    surname[0] = '0';
   if (num > 9) 
    {
        num1++;
        num = num -10;
        surname[0] = '0' + num1;
        name[0] = '0' + num;
        strcat(surname, name);
        strcat(surname, png);
        save_png_to_file(&fruit, surname);
    }
    else
    {
       surname[0] = '0' + num1;
        strcat(surname, name);
        strcat(surname, png);
        save_png_to_file(&fruit, surname);
    }

    for (y = 0; y < fruit.height; y++)
    {
        for (x = 0; x < fruit.width; x++)
        {
            pixel_t* pixel = pixel_at(&fruit, x, y);
            pixel->green = 255;
            pixel->blue = 255;
            pixel->red = 255;
        }

    }
    num++;
}



void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

/* This function takes last element as pivot,
   places the pivot element at its correct
   position in sorted  array, and places
   all smaller (smaller than pivot) to left
   of pivot and all greater elements to
   right of pivot */
int partition(pair arr[], int l, int h, int n)
{
    int x = arr[h].val;
    int i = (l - 1);
    for (int j = l; j <= h - 1; j++) {
        if (arr[j].val <= x) {
            i++;
            swap(&arr[i].val, &arr[j].val);
            swap(&arr[i].key, &arr[j].key);
            DrawAndSave(arr, n);
        }
    }
    swap(&arr[i + 1].val, &arr[h].val);
    swap(&arr[i + 1].key, &arr[h].key);
    return (i + 1);
    DrawAndSave(arr, n );
}


void quickSort(pair A[], int l, int h,int n)   // l=0; h = n -1
{

    if (l < h) 
    {
        DrawAndSave(A, n);
        int p = partition(A, l, h,n);
        quickSort(A, l, p - 1,n);
        DrawAndSave(A, n);
        quickSort(A, p + 1, h,n);
        DrawAndSave(A, n);
    }
}



int main()
{
    printf("Enter the number of numbers\n");
    int n;
    scanf("%d", &n);
    bitmap_t fruit;
    fruit.width = 20*n;
    fruit.height = 20*n;
    fruit.pixels = calloc(sizeof(pixel_t), fruit.width * fruit.height);
    int number;
    pair * arr = (pair*)malloc(n * sizeof(pair));
    puts("Enter the numbers");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &number);
        arr[i].val = number;
    }

    for (int i = 0; i < n; i++)
    {
        arr[i].key = i;
    }
    quickSort(arr, 0, n - 1,n);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i].val);
    }
    printf("\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i].key);
    }
    free(arr);
    return 0;
}
