#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>

#include <png.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

typedef struct  //структура для для
{
    int key;
    int val;
}pair;

/*  цвет */

typedef struct {
    uint8_t red;
    uint8_t green;
    uint8_t blue;
    uint8_t alpha;
} pixel_t;

/* картинка */

typedef struct {
    pixel_t* pixels;
    size_t width;
    size_t height;
} bitmap_t;

/* Given "bitmap", this returns the pixel of bitmap at the point
("x", "y"). */

static pixel_t* pixel_at(bitmap_t* bitmap, int x, int y)
{
    return bitmap->pixels + bitmap->width * y + x;
}

/* Write "bitmap" to a PNG file specified by "path"; returns 0 on
success, non-zero on error. */

static int save_png_to_file(bitmap_t* bitmap, const char* path)
{
    FILE* fp;
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL;
    size_t x, y;
    png_byte** row_pointers = NULL;
    int status = -1;
    int pixel_size = 50;
    int depth = 8;

    fp = fopen(path, "wb");
    if (!fp) {
        goto fopen_failed;
    }

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (png_ptr == NULL) {
        goto png_create_write_struct_failed;
    }

    info_ptr = png_create_info_struct(png_ptr);
    if (info_ptr == NULL) {
        goto png_create_info_struct_failed;
    }


    if (setjmp(png_jmpbuf(png_ptr))) {
        goto png_failure;
    }


    png_set_IHDR(png_ptr,
        info_ptr,
        bitmap->width,
        bitmap->height,
        depth,
        PNG_COLOR_TYPE_RGBA,
        PNG_INTERLACE_NONE,
        PNG_COMPRESSION_TYPE_DEFAULT,
        PNG_FILTER_TYPE_DEFAULT);


    row_pointers = png_malloc(png_ptr, bitmap->height * sizeof(png_byte*));
    for (y = 0; y < bitmap->height; ++y) {
        png_byte* row =
            png_malloc(png_ptr, sizeof(uint8_t) * bitmap->width * pixel_size);
        row_pointers[y] = row;
        for (x = 0; x < bitmap->width; ++x) {
            pixel_t* pixel = pixel_at(bitmap, x, y);
            *row++ = pixel->red;
            *row++ = pixel->green;
            *row++ = pixel->blue;
            *row++ = pixel->alpha;
        }
    }

    /* Write the image data to "fp". */

    png_init_io(png_ptr, fp);
    png_set_rows(png_ptr, info_ptr, row_pointers);
    png_write_png(png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, NULL);

    /* The routine has successfully written the file, so we set
    "status" to a value which indicates success. */

    status = 0;

    for (y = 0; y < bitmap->height; y++) {
        png_free(png_ptr, row_pointers[y]);
    }
    png_free(png_ptr, row_pointers);

png_failure:
png_create_info_struct_failed:
    png_destroy_write_struct(&png_ptr, &info_ptr);
png_create_write_struct_failed:
    fclose(fp);
fopen_failed:
    return status;
}

/* Given "value" and "max", the maximum value which we expect "value"
to take, this returns an integer between 0 and 255 proportional to
"value" divided by "max". */

static int pix(int value, int max)
{
    if (value < 0)
        return 0;
    return (int)(256.0 * ((double)(value) / (double)max));
}





//





void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

/* This function takes last element as pivot,
   places the pivot element at its correct
   position in sorted  array, and places
   all smaller (smaller than pivot) to left
   of pivot and all greater elements to
   right of pivot */
int partition(pair arr[], int l, int h)
{
    int x = arr[h].val;
    int i = (l - 1);

    for (int j = l; j <= h - 1; j++) {
        if (arr[j].val <= x) {
            i++;
            swap(&arr[i].val, &arr[j].val);
            swap(&arr[i].key, &arr[j].key);
        }
    }
    swap(&arr[i + 1].val, &arr[h].val);
    swap(&arr[i + 1].key, &arr[h].key);
    return (i + 1);
}


void quickSort(pair A[], int l, int h)   // l=0; h = длинна -1
{
    bitmap_t fruit;
    fruit.width = 100;
    fruit.height = 100;
    fruit.pixels = calloc(sizeof(pixel_t), fruit.width * fruit.height);
    int y;
    int x;
    int xx1 = 0;
    int n = 6;
    pair* arr = (pair*)malloc(n * sizeof(pair));
    if (l < h) 
    {
        /* Partitioning index */
        int p = partition(A, l, h);
        quickSort(A, l, p - 1);
        quickSort(A, p + 1, h);
    }
    for (int i = 0; i < n; i++)
    {

        for (y = 0; y < arr[i].val * 4; y++)
        {
            for (x = 0; x < 8; x++)
            {
                x = x + xx1;
                pixel_t* pixel = pixel_at(&fruit, x, y);
                pixel->green = 100;
                pixel->blue = 0;
                pixel->red = 0;
                pixel->alpha = pix(99, fruit.width);
                x = x - xx1;
            }

        }
        xx1 += 17;
    }
    save_png_to_file(&fruit, "fruit1.png");
}


int main()
{

    bitmap_t fruit;
    fruit.width = 100;
    fruit.height = 100;
    fruit.pixels = calloc(sizeof(pixel_t), fruit.width * fruit.height);
    int y ;
    int x ;
    int xx1 = 0;
    int xx2 = 0;
  

    
    

      
    int n = 6;
    pair * arr = (pair*)malloc(n * sizeof(pair));
    arr[0].val = 10;
    arr[1].val = 20;
    arr[2].val = 2;
    arr[3].val = 7;
    arr[4].val = 2;
    arr[5].val = 6;

    for (int i = 0; i < n; i++)
    {
        arr[i].key = i;
    }
    quickSort(arr, 0, n - 1);

    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i].val);
    }
    printf("\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i].key);
    }
    free(arr);
    return 0;
}
